# Gmail-Discord自動転送・返信システム 作業手順書

## 目次
1. [開発環境のセットアップ](#1-開発環境のセットアップ)
2. [プロジェクト構造の作成](#2-プロジェクト構造の作成)
3. [API認証の設定](#3-api認証の設定)
4. [メール受信モジュールの実装](#4-メール受信モジュールの実装)
5. [Discord連携モジュールの実装](#5-discord連携モジュールの実装)
6. [宛名管理モジュールの実装](#6-宛名管理モジュールの実装)
7. [ChatGPT連携モジュールの実装](#7-chatgpt連携モジュールの実装)
8. [Googleカレンダー連携モジュールの実装](#8-googleカレンダー連携モジュールの実装)
9. [統合テスト](#9-統合テスト)
10. [デプロイメント](#10-デプロイメント)
11. [運用とメンテナンス](#11-運用とメンテナンス)

---

## 1. 開発環境のセットアップ

### 1.1 必要なツールとライブラリのインストール

```bash
# 仮想環境の作成と有効化
python -m venv venv
source venv/bin/activate  # Windowsの場合: venv\Scripts\activate

# 必要なパッケージのインストール
pip install google-api-python-client google-auth-httplib2 google-auth-oauthlib
pip install discord.py
pip install openai
pip install python-dotenv
pip install sqlalchemy
pip install pytest
```

### 1.2 テスト方法

1. 仮想環境が正しく作成されたか確認
   ```bash
   # 仮想環境が有効になっているか確認
   which python  # Windowsの場合: where python
   # 仮想環境のpythonが表示されることを確認
   ```

2. 必要なパッケージが正しくインストールされたか確認
   ```bash
   pip list | grep google
   pip list | grep discord
   pip list | grep openai
   # 各パッケージが表示されることを確認
   ```

---

## 2. プロジェクト構造の作成

### 2.1 ディレクトリ構造の作成

```bash
mkdir -p gmail_discord_bot/{gmail_module,discord_module,name_module,chatgpt_module,calendar_module,database,utils,tests,config}
touch gmail_discord_bot/__init__.py
touch gmail_discord_bot/{gmail_module,discord_module,name_module,chatgpt_module,calendar_module,database,utils,tests}/__init__.py
touch gmail_discord_bot/main.py
touch gmail_discord_bot/config/config.py
touch gmail_discord_bot/config/.env.example
touch README.md
touch requirements.txt
```

### 2.2 ファイル構造

```
gmail_discord_bot/
├── __init__.py
├── main.py                      # アプリケーションのエントリーポイント
├── gmail_module/                # Gmailとの連携を担当
│   ├── __init__.py
│   ├── gmail_client.py          # Gmail APIクライアント
│   └── email_processor.py       # メール処理ロジック
├── discord_module/              # Discordとの連携を担当
│   ├── __init__.py
│   ├── discord_bot.py           # Discordボットの実装
│   └── message_formatter.py     # メッセージフォーマット処理
├── name_module/                 # 宛名管理を担当
│   ├── __init__.py
│   ├── name_extractor.py        # メールから宛名情報を抽出
│   └── name_manager.py          # 宛名情報の管理
├── chatgpt_module/              # ChatGPT連携を担当
│   ├── __init__.py
│   ├── prompt_generator.py      # プロンプト生成
│   └── response_processor.py    # 応答処理
├── calendar_module/             # Googleカレンダー連携を担当
│   ├── __init__.py
│   ├── calendar_client.py       # カレンダーAPIクライアント
│   └── schedule_analyzer.py     # スケジュール分析
├── database/                    # データベース関連
│   ├── __init__.py
│   ├── models.py                # データモデル
│   └── db_manager.py            # DB操作
├── utils/                       # ユーティリティ関数
│   ├── __init__.py
│   ├── logger.py                # ロギング
│   └── error_handler.py         # エラーハンドリング
├── config/                      # 設定関連
│   ├── config.py                # 設定管理
│   └── .env.example             # 環境変数サンプル
└── tests/                       # テスト
    ├── __init__.py
    ├── test_gmail.py
    ├── test_discord.py
    ├── test_name.py
    ├── test_chatgpt.py
    └── test_calendar.py
```

### 2.3 テスト方法

1. ディレクトリ構造が正しく作成されたか確認
   ```bash
   find gmail_discord_bot -type d | sort
   # 全てのディレクトリが表示されることを確認
   ```

2. 必要なファイルが作成されたか確認
   ```bash
   find gmail_discord_bot -type f -name "*.py" | sort
   # 全てのPythonファイルが表示されることを確認
   ```

---

## 3. API認証の設定

### 3.1 環境変数の設定

`.env`ファイルを作成し、以下の環境変数を設定します：

```bash
cp gmail_discord_bot/config/.env.example gmail_discord_bot/config/.env
```

`.env`ファイルに以下の内容を追加：

```
# Gmail API
GMAIL_CREDENTIALS_FILE=credentials.json
GMAIL_TOKEN_FILE=token.json
GMAIL_SCOPES=https://www.googleapis.com/auth/gmail.readonly,https://www.googleapis.com/auth/gmail.send

# Discord API
DISCORD_BOT_TOKEN=your_discord_bot_token
DISCORD_GUILD_ID=your_discord_guild_id

# OpenAI API
OPENAI_API_KEY=your_openai_api_key

# Google Calendar API
CALENDAR_CREDENTIALS_FILE=calendar_credentials.json
CALENDAR_TOKEN_FILE=calendar_token.json
CALENDAR_SCOPES=https://www.googleapis.com/auth/calendar.readonly

# Database
DATABASE_URL=sqlite:///email_bot.db

# Email Mapping
EMAIL_CHANNEL_MAPPING_FILE=email_channel_mapping.json
```

### 3.2 API認証ファイルの取得

#### 3.2.1 Gmail API

1. Google Cloud Consoleで新しいプロジェクトを作成
2. Gmail APIを有効化
3. OAuth同意画面を設定
4. 認証情報を作成し、credentials.jsonをダウンロード
5. `gmail_discord_bot/config/`ディレクトリに配置

#### 3.2.2 Discord API

1. Discord Developer Portalで新しいアプリケーションを作成
2. Botを追加し、トークンを生成
3. 必要な権限（メッセージ読み取り、送信など）を設定
4. `.env`ファイルにトークンを追加

#### 3.2.3 OpenAI API

1. OpenAIのウェブサイトでアカウントを作成
2. APIキーを生成
3. `.env`ファイルにAPIキーを追加

#### 3.2.4 Google Calendar API

1. Google Cloud Consoleで同じプロジェクトを使用
2. Google Calendar APIを有効化
3. 認証情報を作成し、calendar_credentials.jsonをダウンロード
4. `gmail_discord_bot/config/`ディレクトリに配置

### 3.3 設定ファイルの作成

`gmail_discord_bot/config/config.py`に以下の内容を追加：

```python
import os
import json
from dotenv import load_dotenv
from pathlib import Path

# .envファイルを読み込む
config_dir = Path(__file__).parent
load_dotenv(config_dir / ".env")

# Gmail API設定
GMAIL_CREDENTIALS_FILE = config_dir / os.getenv("GMAIL_CREDENTIALS_FILE")
GMAIL_TOKEN_FILE = config_dir / os.getenv("GMAIL_TOKEN_FILE")
GMAIL_SCOPES = os.getenv("GMAIL_SCOPES").split(",")

# Discord API設定
DISCORD_BOT_TOKEN = os.getenv("DISCORD_BOT_TOKEN")
DISCORD_GUILD_ID = os.getenv("DISCORD_GUILD_ID")

# OpenAI API設定
OPENAI_API_KEY = os.getenv("OPENAI_API_KEY")

# Google Calendar API設定
CALENDAR_CREDENTIALS_FILE = config_dir / os.getenv("CALENDAR_CREDENTIALS_FILE")
CALENDAR_TOKEN_FILE = config_dir / os.getenv("CALENDAR_TOKEN_FILE")
CALENDAR_SCOPES = os.getenv("CALENDAR_SCOPES").split(",")

# データベース設定
DATABASE_URL = os.getenv("DATABASE_URL")

# メールとチャンネルのマッピング
EMAIL_CHANNEL_MAPPING_FILE = config_dir / os.getenv("EMAIL_CHANNEL_MAPPING_FILE")

def get_email_channel_mapping():
    """メールアドレスとDiscordチャンネルのマッピングを取得"""
    try:
        with open(EMAIL_CHANNEL_MAPPING_FILE, 'r') as f:
            return json.load(f)
    except FileNotFoundError:
        # デフォルトの空のマッピングを返す
        return {}
```

### 3.4 テスト方法

1. 環境変数が正しく読み込まれるか確認するテストスクリプト

`gmail_discord_bot/tests/test_config.py`を作成：

```python
import sys
import os
sys.path.append(os.path.dirname(os.path.dirname(os.path.abspath(__file__))))

from config import config

def test_config_loading():
    """設定が正しく読み込まれるかテスト"""
    assert config.DISCORD_BOT_TOKEN is not None
    assert config.OPENAI_API_KEY is not None
    assert len(config.GMAIL_SCOPES) > 0
    print("設定ファイルのテスト成功")

if __name__ == "__main__":
    test_config_loading()
```

2. テストの実行

```bash
python -m gmail_discord_bot.tests.test_config
# "設定ファイルのテスト成功"と表示されることを確認
```

---

## 4. メール受信モジュールの実装

### 4.1 Gmail APIクライアントの実装

`gmail_discord_bot/gmail_module/gmail_client.py`を作成：

```python
import os
import pickle
from googleapiclient.discovery import build
from google_auth_oauthlib.flow import InstalledAppFlow
from google.auth.transport.requests import Request
from pathlib import Path
import base64
import email
from email.header import decode_header

from ..config import config
from ..utils.logger import setup_logger

logger = setup_logger(__name__)

class GmailClient:
    def __init__(self):
        self.creds = None
        self.service = None
        self.initialize_service()
    
    def initialize_service(self):
        """Gmail APIサービスの初期化"""
        if os.path.exists(config.GMAIL_TOKEN_FILE):
            with open(config.GMAIL_TOKEN_FILE, 'rb') as token:
                self.creds = pickle.load(token)
        
        # 認証情報がない、または期限切れの場合
        if not self.creds or not self.creds.valid:
            if self.creds and self.creds.expired and self.creds.refresh_token:
                self.creds.refresh(Request())
            else:
                flow = InstalledAppFlow.from_client_secrets_file(
                    config.GMAIL_CREDENTIALS_FILE, config.GMAIL_SCOPES)
                self.creds = flow.run_local_server(port=0)
            
            # トークンを保存
            with open(config.GMAIL_TOKEN_FILE, 'wb') as token:
                pickle.dump(self.creds, token)
        
        self.service = build('gmail', 'v1', credentials=self.creds)
        logger.info("Gmail APIサービスが初期化されました")
    
    def get_unread_emails(self, max_results=10):
        """未読メールを取得"""
        try:
            results = self.service.users().messages().list(
                userId='me', labelIds=['INBOX', 'UNREAD'], maxResults=max_results
            ).execute()
            
            messages = results.get('messages', [])
            emails = []
            
            for message in messages:
                msg = self.service.users().messages().get(
                    userId='me', id=message['id'], format='full'
                ).execute()
                
                emails.append(self._parse_message(msg))
            
            return emails
        
        except Exception as e:
            logger.error(f"メール取得エラー: {e}")
            return []
    
    def _parse_message(self, message):
        """メッセージをパース"""
        msg_id = message['id']
        payload = message['payload']
        headers = payload.get('headers', [])
        
        # ヘッダー情報を取得
        subject = ""
        sender = ""
        date = ""
        
        for header in headers:
            name = header.get('name', '').lower()
            if name == 'subject':
                subject = header.get('value', '')
            elif name == 'from':
                sender = header.get('value', '')
            elif name == 'date':
                date = header.get('value', '')
        
        # 本文を取得
        body = ""
        
        if 'parts' in payload:
            for part in payload['parts']:
                if part['mimeType'] == 'text/plain':
                    body = base64.urlsafe_b64decode(
                        part['body']['data']).decode('utf-8')
                    break
        elif 'body' in payload and 'data' in payload['body']:
            body = base64.urlsafe_b64decode(
                payload['body']['data']).decode('utf-8')
        
        return {
            'id': msg_id,
            'subject': subject,
            'sender': sender,
            'date': date,
            'body': body,
            'raw_message': message
        }
    
    def mark_as_read(self, msg_id):
        """メールを既読にする"""
        try:
            self.service.users().messages().modify(
                userId='me',
                id=msg_id,
                body={'removeLabelIds': ['UNREAD']}
            ).execute()
            logger.info(f"メール {msg_id} を既読にしました")
            return True
        except Exception as e:
            logger.error(f"既読マーク設定エラー: {e}")
            return False
    
    def send_email(self, to, subject, body, thread_id=None):
        """メールを送信する"""
        try:
            message = email.message.EmailMessage()
            message['To'] = to
            message['Subject'] = subject
            message.set_content(body)
            
            encoded_message = base64.urlsafe_b64encode(message.as_bytes()).decode()
            
            create_message = {
                'raw': encoded_message
            }
            
            if thread_id:
                create_message['threadId'] = thread_id
            
            send_message = self.service.users().messages().send(
                userId='me', body=create_message).execute()
            
            logger.info(f"メール送信成功: {send_message['id']}")
            return send_message
        
        except Exception as e:
            logger.error(f"メール送信エラー: {e}")
            return None
```

### 4.2 メール処理ロジックの実装

`gmail_discord_bot/gmail_module/email_processor.py`を作成：

```python
import re
from ..config import config
from ..utils.logger import setup_logger
from .gmail_client import GmailClient

logger = setup_logger(__name__)

class EmailProcessor:
    def __init__(self, gmail_client=None):
        self.gmail_client = gmail_client or GmailClient()
        self.email_channel_mapping = config.get_email_channel_mapping()
    
    def process_new_emails(self, max_emails=10):
        """新しいメールを処理"""
        emails = self.gmail_client.get_unread_emails(max_emails)
        processed_emails = []
        
        for email_data in emails:
            # 送信者のメールアドレスを抽出
            sender_email = self._extract_email_address(email_data['sender'])
            
            # 対応するDiscordチャンネルを検索
            channel_id = self._get_channel_for_email(sender_email)
            
            if channel_id:
                # 処理対象のメールとしてマーク
                email_data['discord_channel_id'] = channel_id
                processed_emails.append(email_data)
                
                # メールを既読にする
                self.gmail_client.mark_as_read(email_data['id'])
                logger.info(f"メール {email_data['id']} を処理対象としてマーク")
            else:
                logger.info(f"メール {email_data['id']} は処理対象外: マッピングなし")
        
        return processed_emails
    
    def _extract_email_address(self, sender_string):
        """送信者文字列からメールアドレスを抽出"""
        # 'Name <email@example.com>' または 'email@example.com' の形式に対応
        match = re.search(r'<([^>]+)>', sender_string)
        if match:
            return match.group(1).lower()
        else:
            # '<>'がない場合は文字列全体をメールアドレスとみなす
            return sender_string.lower()
    
    def _get_channel_for_email(self, email_address):
        """メールアドレスに対応するDiscordチャンネルIDを取得"""
        # 完全一致
        if email_address in self.email_channel_mapping:
            return self.email_channel_mapping[email_address]
        
        # ドメイン一致（example.com形式のマッピングがある場合）
        domain = email_address.split('@')[-1]
        if domain in self.email_channel_mapping:
            return self.email_channel_mapping[domain]
        
        # ワイルドカードマッピング（*@example.com形式）
        wildcard = f"*@{domain}"
        if wildcard in self.email_channel_mapping:
            return self.email_channel_mapping[wildcard]
        
        return None
```

### 4.3 テスト方法

`gmail_discord_bot/tests/test_gmail.py`を作成：

```python
import sys
import os
import unittest
from unittest.mock import MagicMock, patch
sys.path.append(os.path.dirname(os.path.dirname(os.path.abspath(__file__))))

from gmail_module.gmail_client import GmailClient
from gmail_module.email_processor import EmailProcessor

class TestGmailModule(unittest.TestCase):
    
    @patch('gmail_module.gmail_client.build')
    @patch('gmail_module.gmail_client.InstalledAppFlow')
    @patch('gmail_module.gmail_client.Request')
    def test_gmail_client_initialization(self, mock_request, mock_flow, mock_build):
        """GmailClientの初期化テスト"""
        # モックの設定
        mock_build.return_value = MagicMock()
        
        # テスト実行
        client = GmailClient()
        
        # 検証
        self.assertIsNotNone(client.service)
        mock_build.assert_called_once()
    
    def test_email_processor(self):
        """EmailProcessorのテスト"""
        # モックのGmailClientを作成
        mock_client = MagicMock()
        mock_client.get_unread_emails.return_value = [
            {
                'id': '123',
                'subject': 'テストメール',
                'sender': 'Test User <test@example.com>',
                'date': '2023-01-01',
                'body': 'これはテストメールです。'
            }
        ]
        
        # EmailProcessorのインスタンス化
        processor = EmailProcessor(gmail_client=mock_client)
        
        # email_channel_mappingをモックで設定
        processor.email_channel_mapping = {
            'test@example.com': '123456789'
        }
        
        # テスト実行
        processed = processor.process_new_emails()
        
        # 検証
        self.assertEqual(len(processed), 1)
        self.assertEqual(processed[0]['discord_channel_id'], '123456789')
        mock_client.mark_as_read.assert_called_once_with('123')

if __name__ == '__main__':
    unittest.main()
```

テストの実行：

```bash
python -m unittest gmail_discord_bot.tests.test_gmail
```

---

## 5. Discord連携モジュールの実装

### 5.1 Discordボットの実装

`gmail_discord_bot/discord_module/discord_bot.py`を作成：

```python
import discord
from discord.ext import commands
import asyncio
from ..config import config
from ..utils.logger import setup_logger

logger = setup_logger(__name__)

class DiscordBot:
    def __init__(self):
        self.token = config.DISCORD_BOT_TOKEN
        self.guild_id = config.DISCORD_GUILD_ID
        
        intents = discord.Intents.default()
        intents.message_content = True
        
        self.bot = commands.Bot(command_prefix='!', intents=intents)
        self.setup_events()
        self.setup_commands()
        
        # 応答選択のためのデータ保存
        self.response_options = {}
    
    def setup_events(self):
        """イベントハンドラの設定"""
        @self.bot.event
        async def on_ready():
            logger.info(f'{self.bot.user.name} としてログインしました')
            logger.info(f'Bot ID: {self.bot.user.id}')
            logger.info('------')
    
    def setup_commands(self):
        """コマンドの設定"""
        @self.bot.command(name='help')
        async def help_command(ctx):
            """ヘルプコマンド"""
            help_text = """
            **メール自動返信ボットのコマンド**
            
            `!help` - このヘルプメッセージを表示
            `!status` - ボットのステータスを表示
            `!select [番号]` - 提案された返信から選択（番号は1から始まる）
            `!edit [番号] [新しい内容]` - 提案された返信を編集
            `!send [番号]` - 選択した返信を実際にメールとして送信
            """
            await ctx.send(help_text)
        
        @self.bot.command(name='select')
        async def select_response(ctx, option_number: int):
            """提案された返信から選択"""
            thread_id = str(ctx.channel.id)
            
            if thread_id not in self.response_options:
                await ctx.send("このチャンネルでは返信候補が生成されていません。")
                return
            
            if option_number < 1 or option_number > len(self.response_options[thread_id]['options']):
                await ctx.send(f"1から{len(self.response_options[thread_id]['options'])}の間の番号を選択してください。")
                return
            
            # 選択した返信を保存
            self.response_options[thread_id]['selected'] = option_number - 1
            selected_text = self.response_options[thread_id]['options'][option_number - 1]
            
            await ctx.send(f"返信 {option_number} を選択しました：\n```\n{selected_text}\n```\n`!send {option_number}` で送信できます。")
    
    async def send_email_notification(self, channel_id, email_data):
        """メール通知をDiscordチャンネルに送信"""
        channel = self.bot.get_channel(int(channel_id))
        if not channel:
            logger.error(f"チャンネルが見つかりません: {channel_id}")
            return False
        
        # メール情報を整形
        embed = discord.Embed(
            title=f"新しいメール: {email_data['subject']}",
            color=discord.Color.blue()
        )
        embed.add_field(name="送信者", value=email_data['sender'], inline=False)
        embed.add_field(name="日時", value=email_data['date'], inline=False)
        
        # 本文が長い場合は省略
        body = email_data['body']
        if len(body) > 1000:
            body = body[:997] + "..."
        
        embed.add_field(name="本文", value=body, inline=False)
        
        await channel.send(embed=embed)
        await channel.send("返信候補を生成中...")
        
        return True
    
    async def send_response_options(self, channel_id, email_data, response_options):
        """返信候補をDiscordチャンネルに送信"""
        channel = self.bot.get_channel(int(channel_id))
        if not channel:
            logger.error(f"チャンネルが見つかりません: {channel_id}")
            return False
        
        await channel.send("**返信候補が生成されました**\n以下から選択するか、編集してください：")
        
        # 返信候補を保存
        self.response_options[str(channel_id)] = {
            'email': email_data,
            'options': response_options,
            'selected': None
        }
        
        # 各候補を表示
        for i, option in enumerate(response_options, 1):
            await channel.send(f"**候補 {i}**\n```\n{option}\n```")
        
        await channel.send("選択するには `!select [番号]` を使用してください。")
        return True
    
    def run(self):
        """ボットを実行"""
        self.bot.run(self.token)
    
    def run_async(self):
        """非同期でボットを実行（テスト用）"""
        loop = asyncio.get_event_loop()
        try:
            loop.create_task(self.bot.start(self.token))
        except KeyboardInterrupt:
            loop.run_until_complete(self.bot.close())
        finally:
            loop.close()
```

### 5.2 メッセージフォーマッタの実装

`gmail_discord_bot/discord_module/message_formatter.py`を作成：

```python
import re
from ..utils.logger import setup_logger

logger = setup_logger(__name__)

class MessageFormatter:
    def __init__(self):
        pass
    
    def format_email_for_discord(self, email_data):
        """メールをDiscord表示用にフォーマット"""
        # 基本情報
        formatted = f"**新しいメール**\n"
        formatted += f"**件名:** {email_data['subject']}\n"
        formatted += f"**送信者:** {email_data['sender']}\n"
        formatted += f"**日時:** {email_data['date']}\n\n"
        
        # 本文（長すぎる場合は分割）
        body = email_data['body']
        if len(body) > 1900:  # Discordのメッセージ制限に近い値
            # 本文を分割
            parts = []
            current_part = ""
            for line in body.split('\n'):
                if len(current_part) + len(line) + 1 > 1900:
                    parts.append(current_part)
                    current_part = line
                else:
                    if current_part:
                        current_part += '\n' + line
                    else:
                        current_part = line
            
            if current_part:
                parts.append(current_part)
            
            # 最初の部分を追加
            formatted += f"**本文 (1/{len(parts)}):**\n```\n{parts[0]}\n```"
            return formatted, parts[1:]
        else:
            formatted += f"**本文:**\n```\n{body}\n```"
            return formatted, []
    
    def format_response_options(self, options):
        """返信候補をフォーマット"""
        formatted_options = []
        
        for i, option in enumerate(options, 1):
            formatted = f"**候補 {i}**\n```\n{option}\n```"
            formatted_options.append(formatted)
        
        return formatted_options
    
    def extract_email_thread(self, discord_messages):
        """Discordメッセージからメールスレッドを抽出"""
        email_content = ""
        
        for message in discord_messages:
            if "新しいメール" in message.content:
                # メールの基本情報を抽出
                subject_match = re.search(r'\*\*件名:\*\* (.*?)\n', message.content)
                sender_match = re.search(r'\*\*送信者:\*\* (.*?)\n', message.content)
                
                if subject_match and sender_match:
                    email_content += f"件名: {subject_match.group(1)}\n"
                    email_content += f"送信者: {sender_match.group(1)}\n"
            
            # 本文部分を抽出
            body_match = re.search(r'\*\*本文.*?:\*\*\n```\n(.*?)\n```', message.content, re.DOTALL)
            if body_match:
                email_content += f"本文:\n{body_match.group(1)}\n\n"
        
        return email_content
```

### 5.3 テスト方法

`gmail_discord_bot/tests/test_discord.py`を作成：

```python
import sys
import os
import unittest
from unittest.mock import MagicMock, patch
sys.path.append(os.path.dirname(os.path.dirname(os.path.abspath(__file__))))

from discord_module.message_formatter import MessageFormatter

class TestDiscordModule(unittest.TestCase):
    
    def test_message_formatter(self):
        """MessageFormatterのテスト"""
        formatter = MessageFormatter()
        
        # テスト用のメールデータ
        email_data = {
            'subject': 'テスト件名',
            'sender': 'test@example.com',
            'date': '2023-01-01',
            'body': 'これはテスト本文です。\n改行も含まれています。'
        }
        
        # フォーマットテスト
        formatted, remaining = formatter.format_email_for_discord(email_data)
        
        # 検証
        self.assertIn('テスト件名', formatted)
        self.assertIn('test@example.com', formatted)
        self.assertIn('これはテスト本文です。', formatted)
        self.assertEqual(len(remaining), 0)  # 本文が短いので分割なし
        
        # 長い本文のテスト
        long_body = 'a' * 2000
        email_data['body'] = long_body
        
        formatted, remaining = formatter.format_email_for_discord(email_data)
        
        # 検証
        self.assertGreater(len(remaining), 0)  # 本文が分割されている
    
    def test_response_options_formatting(self):
        """返信候補フォーマットのテスト"""
        formatter = MessageFormatter()
        
        options = [
            "返信候補1です。",
            "返信候補2です。"
        ]
        
        formatted = formatter.format_response_options(options)
        
        # 検証
        self.assertEqual(len(formatted), 2)
        self.assertIn("候補 1", formatted[0])
        self.assertIn("返信候補1です。", formatted[0])
        self.assertIn("候補 2", formatted[1])

if __name__ == '__main__':
    unittest.main()
```

テストの実行：

```bash
python -m unittest gmail_discord_bot.tests.test_discord
```

---

## 6. 宛名管理モジュールの実装

### 6.1 宛名抽出機能の実装

`gmail_discord_bot/name_module/name_extractor.py`を作成：

```python
import re
from ..utils.logger import setup_logger

logger = setup_logger(__name__)

class NameExtractor:
    def __init__(self):
        # 署名を検出するための正規表現パターン
        self.signature_patterns = [
            r'--+\s*\n([\s\S]+)',  # "---" で始まる署名
            r'^\s*(?:敬具|よろしくお願いします|よろしくお願い致します).*?\n([\s\S]+)',  # 日本語の締めの後の署名
            r'(?:Regards|Sincerely|Best regards|Thanks|Thank you).*?\n([\s\S]+)',  # 英語の締めの後の署名
        ]
    
    def extract_from_email(self, email_data):
        """メールから送信者情報を抽出"""
        sender = email_data['sender']
        body = email_data['body']
        
        # 送信者文字列から情報を抽出
        sender_info = self._parse_sender_string(sender)
        
        # 署名から情報を抽出
        signature_info = self._extract_from_signature(body)
        
        # 情報を統合（署名の情報を優先）
        result = {
            'email': sender_info.get('email', ''),
            'name': signature_info.get('name', sender_info.get('name', '')),
            'company': signature_info.get('company', ''),
            'department': signature_info.get('department', ''),
            'title': signature_info.get('title', ''),
            'phone': signature_info.get('phone', ''),
        }
        
        logger.info(f"送信者情報を抽出: {result}")
        return result
    
    def _parse_sender_string(self, sender):
        """送信者文字列をパース（'Name <email@example.com>' 形式）"""
        result = {'email': '', 'name': ''}
        
        # メールアドレスを抽出
        email_match = re.search(r'<([^>]+)>', sender)
        if email_match:
            result['email'] = email_match.group(1)
            # 名前部分を抽出（<>の前の部分）
            name_part = sender.split('<')[0].strip()
            if name_part:
                result['name'] = name_part
        else:
            # '<>'がない場合
            if '@' in sender:
                result['email'] = sender.strip()
                # メールアドレスからユーザー名を抽出
                username = sender.split('@')[0].strip()
                if username:
                    result['name'] = username
        
        return result
    
    def _extract_from_signature(self, body):
        """メール本文から署名情報を抽出"""
        result = {}
        
        # 署名部分を抽出
        signature = None
        for pattern in self.signature_patterns:
            match = re.search(pattern, body, re.MULTILINE)
            if match:
                signature = match.group(1)
                break
        
        if not signature:
            return result
        
        # 署名から情報を抽出
        # 名前を抽出（通常は署名の最初の行）
        lines = signature.strip().split('\n')
        if lines:
            result['name'] = lines[0].strip()
        
        # 会社名を抽出（よくある形式: 株式会社XXX、XXX株式会社、XXX Co., Ltd.など）
        company_patterns = [
            r'(株式会社\S+)',
            r'(\S+株式会社)',
            r'(\S+\s*Co[\.,]\s*Ltd\.)',
            r'(\S+\s*Corporation)',
            r'(\S+\s*Inc\.)',
        ]
        
        for line in lines:
            for pattern in company_patterns:
                match = re.search(pattern, line)
                if match:
                    result['company'] = match.group(1)
                    break
            
            # 部署名・役職を抽出
            dept_patterns = [
                r'(部長|課長|マネージャー|リーダー|ディレクター|エンジニア)',
                r'(Department|Division|Team)',
            ]
            
            for pattern in dept_patterns:
                match = re.search(pattern, line)
                if match:
                    if '部' in line or 'Department' in line or 'Division' in line:
                        result['department'] = line.strip()
                    else:
                        result['title'] = line.strip()
            
            # 電話番号を抽出
            phone_match = re.search(r'(?:Tel|TEL|電話)[:：]?\s*(\+?[\d\-\(\)\s]+)', line)
            if phone_match:
                result['phone'] = phone_match.group(1).strip()
        
        return result
```

### 6.2 宛名管理機能の実装

`gmail_discord_bot/name_module/name_manager.py`を作成：

```python
import json
import os
from pathlib import Path
from ..utils.logger import setup_logger
from .name_extractor import NameExtractor

logger = setup_logger(__name__)

class NameManager:
    def __init__(self, db_file=None):
        self.db_file = db_file or Path(__file__).parent.parent / 'config' / 'name_database.json'
        self.name_db = self._load_database()
        self.extractor = NameExtractor()
    
    def _load_database(self):
        """宛名データベースを読み込む"""
        if os.path.exists(self.db_file):
            try:
                with open(self.db_file, 'r', encoding='utf-8') as f:
                    return json.load(f)
            except Exception as e:
                logger.error(f"宛名データベース読み込みエラー: {e}")
                return {}
        else:
            logger.info(f"宛名データベースが存在しないため、新規作成します: {self.db_file}")
            return {}
    
    def _save_database(self):
        """宛名データベースを保存"""
        try:
            # ディレクトリが存在しない場合は作成
            os.makedirs(os.path.dirname(self.db_file), exist_ok=True)
            
            with open(self.db_file, 'w', encoding='utf-8') as f:
                json.dump(self.name_db, f, ensure_ascii=False, indent=2)
            logger.info("宛名データベースを保存しました")
            return True
        except Exception as e:
            logger.error(f"宛名データベース保存エラー: {e}")
            return False
    
    def process_email(self, email_data):
        """メールから送信者情報を抽出し、データベースを更新"""
        # 送信者情報を抽出
        sender_info = self.extractor.extract_from_email(email_data)
        email = sender_info['email']
        
        if not email:
            logger.warning("メールアドレスが抽出できませんでした")
            return None
        
        # データベースを更新
        if email in self.name_db:
            # 既存の情報を更新（空でない値のみ）
            for key, value in sender_info.items():
                if value:
                    self.name_db[email][key] = value
        else:
            # 新規エントリ
            self.name_db[email] = sender_info
        
        # データベースを保存
        self._save_database()
        
        return self.name_db[email]
    
    def get_address_info(self, email):
        """メールアドレスに対応する宛名情報を取得"""
        return self.name_db.get(email, {})
    
    def format_address(self, email):
        """メールアドレスから適切な宛名形式を生成"""
        info = self.get_address_info(email)
        
        # 会社名と名前の両方がある場合
        if info.get('company') and info.get('name'):
            return f"{info['company']} {info['name']}様"
        
        # 会社名のみある場合
        elif info.get('company'):
            return f"{info['company']} ご担当者様"
        
        # 名前のみある場合
        elif info.get('name'):
            return f"{info['name']}様"
        
        # どちらもない場合
        else:
            return "お世話になっております"
    
    def update_address_info(self, email, info):
        """宛名情報を手動で更新"""
        if email in self.name_db:
            # 既存の情報を更新
            for key, value in info.items():
                if key in self.name_db[email]:
                    self.name_db[email][key] = value
        else:
            # 新規エントリ
            self.name_db[email] = info
        
        # データベースを保存
        return self._save_database()
```

### 6.3 テスト方法

`gmail_discord_bot/tests/test_name.py`を作成：

```python
import sys
import os
import unittest
import tempfile
import json
from pathlib import Path
sys.path.append(os.path.dirname(os.path.dirname(os.path.abspath(__file__))))

from name_module.name_extractor import NameExtractor
from name_module.name_manager import NameManager

class TestNameModule(unittest.TestCase):
    
    def test_name_extractor(self):
        """NameExtractorのテスト"""
        extractor = NameExtractor()
        
        # テスト用のメールデータ
        email_data = {
            'sender': '山田太郎 <yamada@example.co.jp>',
            'body': '''
            お世話になっております。
            ミーティングの件、承知しました。
            
            よろしくお願いいたします。
            
            --
            山田 太郎
            株式会社サンプル
            営業部
            Tel: 03-1234-5678
            '''
        }
        
        # 抽出テスト
        result = extractor.extract_from_email(email_data)
        
        # 検証
        self.assertEqual(result['email'], 'yamada@example.co.jp')
        self.assertEqual(result['name'], '山田 太郎')
        self.assertEqual(result['company'], '株式会社サンプル')
        self.assertIn('営業部', result['department'])
        self.assertIn('03-1234-5678', result['phone'])
    
    def test_name_manager(self):
        """NameManagerのテスト"""
        # 一時ファイルを使用してテスト
        with tempfile.NamedTemporaryFile(delete=False) as temp:
            temp_path = temp.name
        
        try:
            # 空のJSONファイルを作成
            with open(temp_path, 'w') as f:
                json.dump({}, f)
            
            # NameManagerのインスタンス化
            manager = NameManager(db_file=temp_path)
            
            # テスト用のメールデータ
            email_data = {
                'sender': '山田太郎 <yamada@example.co.jp>',
                'body': '''
                お世話になっております。
                ミーティングの件、承知しました。
                
                よろしくお願いいたします。
                
                --
                山田 太郎
                株式会社サンプル
                営業部
                Tel: 03-1234-5678
                '''
            }
            
            # 処理テスト
            result = manager.process_email(email_data)
            
            # 検証
            self.assertEqual(result['email'], 'yamada@example.co.jp')
            self.assertEqual(result['name'], '山田 太郎')
            
            # 宛名フォーマットのテスト
            address = manager.format_address('yamada@example.co.jp')
            self.assertEqual(address, '株式会社サンプル 山田 太郎様')
            
            # 存在しないメールアドレスのテスト
            address = manager.format_address('unknown@example.com')
            self.assertEqual(address, 'お世話になっております')
            
            # データベースが保存されたか確認
            with open(temp_path, 'r') as f:
                saved_data = json.load(f)
            
            self.assertIn('yamada@example.co.jp', saved_data)
            
        finally:
            # テスト後に一時ファイルを削除
            if os.path.exists(temp_path):
                os.unlink(temp_path)

if __name__ == '__main__':
    unittest.main()
```

テストの実行：

```bash
python -m unittest gmail_discord_bot.tests.test_name
```

---

## 7. ChatGPT連携モジュールの実装

### 7.1 プロンプト生成機能の実装

`gmail_discord_bot/chatgpt_module/prompt_generator.py`を作成：

```python
import re
from ..utils.logger import setup_logger

logger = setup_logger(__name__)

class PromptGenerator:
    def __init__(self):
        # 日程調整関連のキーワード
        self.schedule_keywords = [
            '日程', 'スケジュール', '予定', '空き時間', '都合', '面談', '面接',
            '打ち合わせ', 'ミーティング', '会議', '訪問', '来社',
            'schedule', 'meeting', 'appointment', 'interview', 'visit'
        ]
    
    def is_schedule_related(self, email_data):
        """メールが日程調整に関連するかを判定"""
        subject = email_data['subject'].lower()
        body = email_data['body'].lower()
        
        # 件名または本文に日程調整関連のキーワードが含まれるか確認
        for keyword in self.schedule_keywords:
            if keyword in subject or keyword in body:
                logger.info(f"日程調整関連のメールと判定: キーワード '{keyword}' を検出")
                return True
        
        return False
    
    def generate_normal_prompt(self, email_data, sender_info, address):
        """通常の返信用プロンプトを生成"""
        prompt = f"""
あなたは、プロフェッショナルなビジネスメールの返信を作成するアシスタントです。
以下のメールに対して、丁寧かつ適切なビジネスメール形式の返信を3つの異なるバリエーションで作成してください。

# 元のメール情報
件名: {email_data['subject']}
送信者: {email_data['sender']}
本文:
{email_data['body']}

# 返信の要件
1. 宛名は「{address}」を使用してください。
2. 日本語のビジネスメールとして適切な敬語と構成を使用してください。
3. 元のメールの内容に対して具体的に応答してください。
4. 簡潔かつ明確な文章を心がけてください。
5. 署名は「株式会社〇〇 山田太郎」としてください。
6. 各バリエーションは異なる表現や構成を持つようにしてください。
7. 返信は完全な形式（宛名から署名まで）で作成してください。

それぞれのバリエーションを「案1」「案2」「案3」として明確に区別してください。
"""
        return prompt
    
    def generate_schedule_prompt(self, email_data, sender_info, address, available_slots):
        """日程調整用プロンプトを生成"""
        # 利用可能な日時スロットをフォーマット
        slots_text = "\n".join([f"- {slot}" for slot in available_slots])
        
        prompt = f"""
あなたは、プロフェッショナルなビジネスメールの返信を作成するアシスタントです。
以下の日程調整に関するメールに対して、丁寧かつ適切なビジネスメール形式の返信を3つの異なるバリエーションで作成してください。

# 元のメール情報
件名: {email_data['subject']}
送信者: {email_data['sender']}
本文:
{email_data['body']}

# 利用可能な日時スロット
以下の日時が空いています：
{slots_text}

# 返信の要件
1. 宛名は「{address}」を使用してください。
2. 日本語のビジネスメールとして適切な敬語と構成を使用してください。
3. 元のメールの内容に対して具体的に応答してください。
4. 上記の利用可能な日時スロットから、2〜3の候補日時を提案してください。
5. 簡潔かつ明確な文章を心がけてください。
6. 署名は「株式会社〇〇 山田太郎」としてください。
7. 各バリエーションは異なる表現や構成を持つようにしてください。
8. 返信は完全な形式（宛名から署名まで）で作成してください。

それぞれのバリエーションを「案1」「案2」「案3」として明確に区別してください。
"""
        return prompt
```

### 7.2 応答処理機能の実装

`gmail_discord_bot/chatgpt_module/response_processor.py`を作成：

```python
import re
import openai
from ..config import config
from ..utils.logger import setup_logger

logger = setup_logger(__name__)

class ResponseProcessor:
    def __init__(self):
        openai.api_key = config.OPENAI_API_KEY
    
    async def generate_responses(self, prompt, num_responses=3):
        """ChatGPT APIを使用して返信を生成"""
        try:
            response = openai.ChatCompletion.create(
                model="gpt-4",  # または利用可能な最新モデル
                messages=[
                    {"role": "system", "content": "あなたはプロフェッショナルなビジネスメール返信を作成するアシスタントです。"},
                    {"role": "user", "content": prompt}
                ],
                temperature=0.7,
                max_tokens=2000,
                n=1
            )
            
            # レスポンスから返信テキストを抽出
            response_text = response.choices[0].message.content
            
            # 返信を分割（「案1」「案2」「案3」で区切る）
            responses = self._split_responses(response_text)
            
            logger.info(f"{len(responses)}件の返信候補を生成しました")
            return responses
        
        except Exception as e:
            logger.error(f"ChatGPT API呼び出しエラー: {e}")
            # エラー時のフォールバック
            return [
                "申し訳ありません。返信の生成中にエラーが発生しました。",
                "しばらく経ってからもう一度お試しください。"
            ]
    
    def _split_responses(self, response_text):
        """ChatGPTの応答から個別の返信案を抽出"""
        # 「案1」「案2」「案3」などのパターンで分割
        pattern = r'(?:^|\n)(?:案|パターン|返信案|バリエーション)\s*(\d+)[：:]\s*\n'
        splits = re.split(pattern, response_text, flags=re.MULTILINE)
        
        if len(splits) <= 1:
            # パターンが見つからない場合は、全体を1つの返信として扱う
            return [response_text.strip()]
        
        # 最初の要素はヘッダー部分なので除外
        splits = splits[1:]
        
        # 番号と内容のペアに整形
        responses = []
        for i in range(0, len(splits), 2):
            if i + 1 < len(splits):
                responses.append(splits[i + 1].strip())
        
        # 返信が取得できなかった場合
        if not responses:
            return [response_text.strip()]
        
        return responses
    
    def clean_response(self, response_text):
        """返信テキストをクリーンアップ"""
        # 余分な空白行を削除
        cleaned = re.sub(r'\n{3,}', '\n\n', response_text)
        
        # 「案X:」などのプレフィックスを削除
        cleaned = re.sub(r'^(?:案|パターン|返信案|バリエーション)\s*\d+[：:]\s*\n', '', cleaned, flags=re.MULTILINE)
        
        return cleaned.strip()
```

### 7.3 テスト方法

`gmail_discord_bot/tests/test_chatgpt.py`を作成：

```python
import sys
import os
import unittest
from unittest.mock import MagicMock, patch
import asyncio
sys.path.append(os.path.dirname(os.path.dirname(os.path.abspath(__file__))))

from chatgpt_module.prompt_generator import PromptGenerator
from chatgpt_module.response_processor import ResponseProcessor

class TestChatGPTModule(unittest.TestCase):
    
    def test_prompt_generator(self):
        """PromptGeneratorのテスト"""
        generator = PromptGenerator()
        
        # 通常のメール
        normal_email = {
            'subject': 'プロジェクト進捗について',
            'sender': 'test@example.com',
            'body': 'プロジェクトの進捗状況を教えてください。'
        }
        
        # 日程調整のメール
        schedule_email = {
            'subject': 'ミーティングの日程調整',
            'sender': 'test@example.com',
            'body': '来週のミーティングの日程を調整したいと思います。'
        }
        
        # 日程調整判定のテスト
        self.assertFalse(generator.is_schedule_related(normal_email))
        self.assertTrue(generator.is_schedule_related(schedule_email))
        
        # プロンプト生成のテスト
        sender_info = {'name': '山田太郎', 'company': '株式会社サンプル'}
        address = '株式会社サンプル 山田太郎様'
        
        normal_prompt = generator.generate_normal_prompt(normal_email, sender_info, address)
        self.assertIn('プロジェクト進捗について', normal_prompt)
        self.assertIn(address, normal_prompt)
        
        available_slots = ['2023-01-15 14:00-15:00', '2023-01-16 10:00-11:00']
        schedule_prompt = generator.generate_schedule_prompt(
            schedule_email, sender_info, address, available_slots
        )
        self.assertIn('ミーティングの日程調整', schedule_prompt)
        self.assertIn('2023-01-15', schedule_prompt)
        self.assertIn(address, schedule_prompt)
    
    @patch('chatgpt_module.response_processor.openai.ChatCompletion.create')
    def test_response_processor(self, mock_create):
        """ResponseProcessorのテスト"""
        # モックの設定
        mock_response = MagicMock()
        mock_response.choices[0].message.content = """
案1:
山田様

お世話になっております。株式会社サンプルの佐藤です。

ご連絡ありがとうございます。

よろしくお願いいたします。

株式会社〇〇
山田太郎

案2:
山田様

お問い合わせいただきありがとうございます。

ご確認よろしくお願いいたします。

株式会社〇〇
山田太郎

案3:
山田様

メールありがとうございます。

今後ともよろしくお願いいたします。

株式会社〇〇
山田太郎
"""
        mock_create.return_value = mock_response
        
        processor = ResponseProcessor()
        
        # 非同期関数をテストするためのヘルパー関数
        async def run_async_test():
            prompt = "テストプロンプト"
            responses = await processor.generate_responses(prompt)
            return responses
        
        # テスト実行
        loop = asyncio.get_event_loop()
        responses = loop.run_until_complete(run_async_test())
        
        # 検証
        self.assertEqual(len(responses), 3)
        self.assertIn('山田様', responses[0])
        self.assertIn('お問い合わせ', responses[1])
        self.assertIn('メールありがとう', responses[2])
        
        # クリーンアップのテスト
        cleaned = processor.clean_response("案1:\n山田様\n\nテスト\n\n\n\n署名")
        self.assertEqual(cleaned, "山田様\n\nテスト\n\n署名")

if __name__ == '__main__':
    unittest.main()
```

テストの実行：

```bash
python -m unittest gmail_discord_bot.tests.test_chatgpt
```

---

## 8. Googleカレンダー連携モジュールの実装

### 8.1 カレンダークライアントの実装

`gmail_discord_bot/calendar_module/calendar_client.py`を作成：

```python
import os
import pickle
import datetime
from googleapiclient.discovery import build
from google_auth_oauthlib.flow import InstalledAppFlow
from google.auth.transport.requests import Request
from pathlib import Path

from ..config import config
from ..utils.logger import setup_logger

logger = setup_logger(__name__)

class CalendarClient:
    def __init__(self):
        self.creds = None
        self.service = None
        self.initialize_service()
    
    def initialize_service(self):
        """GoogleカレンダーAPIサービスの初期化"""
        if os.path.exists(config.CALENDAR_TOKEN_FILE):
            with open(config.CALENDAR_TOKEN_FILE, 'rb') as token:
                self.creds = pickle.load(token)
        
        # 認証情報がない、または期限切れの場合
        if not self.creds or not self.creds.valid:
            if self.creds and self.creds.expired and self.creds.refresh_token:
                self.creds.refresh(Request())
            else:
                flow = InstalledAppFlow.from_client_secrets_file(
                    config.CALENDAR_CREDENTIALS_FILE, config.CALENDAR_SCOPES)
                self.creds = flow.run_local_server(port=0)
            
            # トークンを保存
            with open(config.CALENDAR_TOKEN_FILE, 'wb') as token:
                pickle.dump(self.creds, token)
        
        self.service = build('calendar', 'v3', credentials=self.creds)
        logger.info("GoogleカレンダーAPIサービスが初期化されました")
    
    def get_calendar_list(self):
        """利用可能なカレンダーのリストを取得"""
        try:
            calendars = self.service.calendarList().list().execute()
            return calendars.get('items', [])
        except Exception as e:
            logger.error(f"カレンダーリスト取得エラー: {e}")
            return []
    
    def get_events(self, calendar_id='primary', time_min=None, time_max=None, max_results=10):
        """指定期間のイベントを取得"""
        try:
            # デフォルトは現在から1週間
            if not time_min:
                time_min = datetime.datetime.utcnow().isoformat() + 'Z'
            if not time_max:
                time_max = (datetime.datetime.utcnow() + datetime.timedelta(days=7)).isoformat() + 'Z'
            
            events_result = self.service.events().list(
                calendarId=calendar_id,
                timeMin=time_min,
                timeMax=time_max,
                maxResults=max_results,
                singleEvents=True,
                orderBy='startTime'
            ).execute()
            
            return events_result.get('items', [])
        
        except Exception as e:
            logger.error(f"イベント取得エラー: {e}")
            return []
    
    def get_free_busy(self, calendar_ids=['primary'], time_min=None, time_max=None):
        """指定期間の空き状況を取得"""
        try:
            # デフォルトは現在から1週間
            if not time_min:
                time_min = datetime.datetime.utcnow().isoformat() + 'Z'
            if not time_max:
                time_max = (datetime.datetime.utcnow() + datetime.timedelta(days=7)).isoformat() + 'Z'
            
            body = {
                "timeMin": time_min,
                "timeMax": time_max,
                "items": [{"id": calendar_id} for calendar_id in calendar_ids]
            }
            
            free_busy_result = self.service.freebusy().query(body=body).execute()
            return free_busy_result
        
        except Exception as e:
            logger.error(f"空き状況取得エラー: {e}")
            return {}
```

### 8.2 スケジュール分析機能の実装

`gmail_discord_bot/calendar_module/schedule_analyzer.py`を作成：

```python
import datetime
import pytz
from ..utils.logger import setup_logger
from .calendar_client import CalendarClient

logger = setup_logger(__name__)

class ScheduleAnalyzer:
    def __init__(self, calendar_client=None):
        self.calendar_client = calendar_client or CalendarClient()
        self.jst = pytz.timezone('Asia/Tokyo')
    
    def get_available_slots(self, days=7, working_hours=(9, 18), duration_minutes=60):
        """利用可能な時間枠を取得"""
        try:
            # 現在時刻（JST）
            now = datetime.datetime.now(self.jst)
            
            # 検索期間の設定
            start_date = now.replace(hour=0, minute=0, second=0, microsecond=0)
            end_date = (start_date + datetime.timedelta(days=days)).replace(hour=23, minute=59, second=59)
            
            # UTC形式に変換
            time_min = start_date.astimezone(pytz.UTC).isoformat()
            time_max = end_date.astimezone(pytz.UTC).isoformat()
            
            # 予定を取得
            events = self.calendar_client.get_events(
                time_min=time_min,
                time_max=time_max,
                max_results=100
            )
            
            # 予定のある時間帯をリストアップ
            busy_slots = []
            for event in events:
                # 終日イベントの場合
                if 'date' in event.get('start', {}):
                    start_date_str = event['start']['date']
                    end_date_str = event['end']['date']
                    start_dt = datetime.datetime.fromisoformat(start_date_str)
                    end_dt = datetime.datetime.fromisoformat(end_date_str)
                    
                    # 終日イベントは営業時間全体を埋める
                    current_date = start_dt
                    while current_date < end_dt:
                        busy_slots.append((
                            self.jst.localize(datetime.datetime.combine(current_date, datetime.time(working_hours[0], 0))),
                            self.jst.localize(datetime.datetime.combine(current_date, datetime.time(working_hours[1], 0)))
                        ))
                        current_date += datetime.timedelta(days=1)
                
                # 通常のイベントの場合
                elif 'dateTime' in event.get('start', {}) and 'dateTime' in event.get('end', {}):
                    start_dt = datetime.datetime.fromisoformat(event['start']['dateTime'].replace('Z', '+00:00'))
                    end_dt = datetime.datetime.fromisoformat(event['end']['dateTime'].replace('Z', '+00:00'))
                    
                    # JSTに変換
                    start_dt = start_dt.astimezone(self.jst)
                    end_dt = end_dt.astimezone(self.jst)
                    
                    busy_slots.append((start_dt, end_dt))
            
            # 利用可能な時間枠を生成
            available_slots = []
            current_date = start_date
            
            # 指定日数分ループ
            for day in range(days):
                current_date = start_date + datetime.timedelta(days=day)
                
                # 土日はスキップ
                if current_date.weekday() >= 5:  # 5=土曜日, 6=日曜日
                    continue
                
                # 営業時間内で1時間ごとにスロットを生成
                for hour in range(working_hours[0], working_hours[1] - (duration_minutes // 60)):
                    for minute in [0, 30]:  # 30分単位でスロットを生成
                        if hour == working_hours[1] - 1 and minute + duration_minutes > 60:
                            continue
                        
                        slot_start = self.jst.localize(datetime.datetime.combine(
                            current_date.date(), datetime.time(hour, minute)
                        ))
                        
                        # 現在時刻より前のスロットはスキップ
                        if slot_start <= now:
                            continue
                        
                        slot_end = slot_start + datetime.timedelta(minutes=duration_minutes)
                        
                        # 予定と重複しないかチェック
                        is_available = True
                        for busy_start, busy_end in busy_slots:
                            # スロットが予定と重複する場合
                            if (slot_start < busy_end and slot_end > busy_start):
                                is_available = False
                                break
                        
                        if is_available:
                            # フォーマット: "2023年1月15日(月) 14:00-15:00"
                            weekday_names = ["月", "火", "水", "木", "金", "土", "日"]
                            weekday = weekday_names[slot_start.weekday()]
                            
                            slot_str = f"{slot_start.year}年{slot_start.month}月{slot_start.day}日({weekday}) "
                            slot_str += f"{slot_start.hour:02d}:{slot_start.minute:02d}-"
                            slot_str += f"{slot_end.hour:02d}:{slot_end.minute:02d}"
                            
                            available_slots.append(slot_str)
            
            logger.info(f"{len(available_slots)}件の利用可能なスロットを見つけました")
            return available_slots
        
        except Exception as e:
            logger.error(f"スケジュール分析エラー: {e}")
            # エラー時は仮のスロットを返す
            return [
                f"{(now + datetime.timedelta(days=i)).strftime('%Y年%m月%d日')}の午後",
                f"{(now + datetime.timedelta(days=i+1)).strftime('%Y年%m月%d日')}の午前"
            ]
    
    def analyze_email_for_dates(self, email_body):
        """メール本文から日付に関する情報を抽出"""
        # 実装例：正規表現で日付を抽出する
        # この部分は必要に応じて拡張可能
        return []
```

### 8.3 テスト方法

`gmail_discord_bot/tests/test_calendar.py`を作成：

```python
import sys
import os
import unittest
from unittest.mock import MagicMock, patch
import datetime
import pytz
sys.path.append(os.path.dirname(os.path.dirname(os.path.abspath(__file__))))

from calendar_module.calendar_client import CalendarClient
from calendar_module.schedule_analyzer import ScheduleAnalyzer

class TestCalendarModule(unittest.TestCase):
    
    @patch('calendar_module.calendar_client.build')
    @patch('calendar_module.calendar_client.InstalledAppFlow')
    @patch('calendar_module.calendar_client.Request')
    def test_calendar_client_initialization(self, mock_request, mock_flow, mock_build):
        """CalendarClientの初期化テスト"""
        # モックの設定
        mock_build.return_value = MagicMock()
        
        # テスト実行
        client = CalendarClient()
        
        # 検証
        self.assertIsNotNone(client.service)
        mock_build.assert_called_once()
    
    def test_schedule_analyzer(self):
        """ScheduleAnalyzerのテスト"""
        # モックのCalendarClientを作成
        mock_client = MagicMock()
        
        # get_eventsの戻り値を設定
        now = datetime.datetime.now()
        tomorrow = now + datetime.timedelta(days=1)
        
        # イベントのモックデータ
        mock_events = [
            {
                'summary': 'テストイベント1',
                'start': {
                    'dateTime': now.replace(hour=10, minute=0).isoformat() + 'Z'
                },
                'end': {
                    'dateTime': now.replace(hour=11, minute=0).isoformat() + 'Z'
                }
            },
            {
                'summary': '終日イベント',
                'start': {
                    'date': tomorrow.date().isoformat()
                },
                'end': {
                    'date': (tomorrow + datetime.timedelta(days=1)).date().isoformat()
                }
            }
        ]
        
        mock_client.get_events.return_value = mock_events
        
        # ScheduleAnalyzerのインスタンス化
        analyzer = ScheduleAnalyzer(calendar_client=mock_client)
        
        # テスト実行
        available_slots = analyzer.get_available_slots(days=3)
        
        # 検証
        self.assertIsInstance(available_slots, list)
        mock_client.get_events.assert_called_once()

if __name__ == '__main__':
    unittest.main()
```

テストの実行：

```bash
python -m unittest gmail_discord_bot.tests.test_calendar
```

---

## 9. 統合テスト

### 9.1 メインアプリケーションの実装

`gmail_discord_bot/main.py`を作成：

```python
import asyncio
import time
import threading
from pathlib import Path
import logging

from gmail_module.gmail_client import GmailClient
from gmail_module.email_processor import EmailProcessor
from discord_module.discord_bot import DiscordBot
from discord_module.message_formatter import MessageFormatter
from name_module.name_manager import NameManager
from chatgpt_module.prompt_generator import PromptGenerator
from chatgpt_module.response_processor import ResponseProcessor
from calendar_module.schedule_analyzer import ScheduleAnalyzer
from utils.logger import setup_logger

logger = setup_logger(__name__)

class EmailBot:
    def __init__(self):
        # 各モジュールの初期化
        self.gmail_client = GmailClient()
        self.email_processor = EmailProcessor(self.gmail_client)
        self.discord_bot = DiscordBot()
        self.message_formatter = MessageFormatter()
        self.name_manager = NameManager()
        self.prompt_generator = PromptGenerator()
        self.response_processor = ResponseProcessor()
        self.schedule_analyzer = ScheduleAnalyzer()
        
        # 処理中のメールIDを追跡
        self.processing_emails = set()
        
        # 定期チェックの設定
        self.check_interval = 60  # 60秒ごとにメールをチェック
    
    async def process_email_for_discord(self, email_data):
        """メールを処理してDiscordに送信"""
        try:
            # 処理中のメールをトラッキング
            if email_data['id'] in self.processing_emails:
                logger.info(f"メール {email_data['id']} は既に処理中です")
                return
            
            self.processing_emails.add(email_data['id'])
            
            # 送信者情報を処理
            sender_info = self.name_manager.process_email(email_data)
            sender_email = sender_info['email']
            
            # 宛名を生成
            address = self.name_manager.format_address(sender_email)
            
            # Discordチャンネルにメール通知を送信
            channel_id = email_data['discord_channel_id']
            await self.discord_bot.send_email_notification(channel_id, email_data)
            
            # 日程調整関連のメールかどうかを判定
            is_schedule = self.prompt_generator.is_schedule_related(email_data)
            
            # プロンプトを生成
            if is_schedule:
                # 利用可能なスロットを取得
                available_slots = self.schedule_analyzer.get_available_slots()
                prompt = self.prompt_generator.generate_schedule_prompt(
                    email_data, sender_info, address, available_slots
                )
            else:
                prompt = self.prompt_generator.generate_normal_prompt(
                    email_data, sender_info, address
                )
            
            # 返信候補を生成
            responses = await self.response_processor.generate_responses(prompt)
            
            # 返信候補をDiscordに送信
            await self.discord_bot.send_response_options(channel_id, email_data, responses)
            
            # 処理完了したメールをトラッキングから削除
            self.processing_emails.remove(email_data['id'])
            
        except Exception as e:
            logger.error(f"メール処理エラー: {e}")
            if email_data['id'] in self.processing_emails:
                self.processing_emails.remove(email_data['id'])
    
    async def check_emails(self):
        """新しいメールをチェックして処理"""
        try:
            # 新しいメールを取得
            emails = self.email_processor.process_new_emails()
            
            if emails:
                logger.info(f"{len(emails)}件の新しいメールを処理します")
                
                # 各メールを処理
                for email_data in emails:
                    await self.process_email_for_discord(email_data)
            else:
                logger.info("新しいメールはありません")
        
        except Exception as e:
            logger.error(f"メールチェックエラー: {e}")
    
    async def periodic_check(self):
        """定期的にメールをチェック"""
        while True:
            await self.check_emails()
            await asyncio.sleep(self.check_interval)
    
    def start_periodic_check(self):
        """非同期の定期チェックを開始"""
        loop = asyncio.new_event_loop()
        asyncio.set_event_loop(loop)
        
        try:
            loop.run_until_complete(self.periodic_check())
        except KeyboardInterrupt:
            logger.info("定期チェックを停止します")
        finally:
            loop.close()
    
    def run(self):
        """ボットを実行"""
        # 定期チェックを別スレッドで開始
        check_thread = threading.Thread(target=self.start_periodic_check)
        check_thread.daemon = True
        check_thread.start()
        
        # Discordボットを実行
        logger.info("Discordボットを起動します")
        self.discord_bot.run()

if __name__ == "__main__":
    bot = EmailBot()
    bot.run()
```

### 9.2 統合テストの実装

`gmail_discord_bot/tests/test_integration.py`を作成：

```python
import sys
import os
import unittest
from unittest.mock import MagicMock, patch
import asyncio
sys.path.append(os.path.dirname(os.path.dirname(os.path.abspath(__file__))))

from main import EmailBot

class TestIntegration(unittest.TestCase):
    
    @patch('main.GmailClient')
    @patch('main.DiscordBot')
    @patch('main.NameManager')
    @patch('main.ResponseProcessor')
    @patch('main.ScheduleAnalyzer')
    async def test_email_processing_flow(self, mock_scheduler, mock_response, mock_name, mock_discord, mock_gmail):
        """メール処理フローの統合テスト"""
        # モックの設定
        mock_email_processor = MagicMock()
        mock_gmail.return_value.get_unread_emails.return_value = []
        
        # テスト用のメールデータ
        test_email = {
            'id': 'test123',
            'subject': 'テストメール',
            'sender': 'Test User <test@example.com>',
            'date': '2023-01-01',
            'body': 'これはテストメールです。',
            'discord_channel_id': '123456789'
        }
        
        mock_email_processor.process_new_emails.return_value = [test_email]
        
        # 名前管理のモック
        mock_name.return_value.process_email.return_value = {
            'email': 'test@example.com',
            'name': 'Test User',
            'company': 'Test Company'
        }
        mock_name.return_value.format_address.return_value = 'Test Company Test User様'
        
        # 返信生成のモック
        mock_response.return_value.generate_responses.return_value = [
            "返信候補1",
            "返信候補2"
        ]
        
        # スケジュール分析のモック
        mock_scheduler.return_value.get_available_slots.return_value = [
            "2023年1月15日(月) 14:00-15:00",
            "2023年1月16日(火) 10:00-11:00"
        ]
        
        # EmailBotのインスタンス化
        bot = EmailBot()
        bot.email_processor = mock_email_processor
        
        # テスト実行
        await bot.check_emails()
        
        # 検証
        mock_email_processor.process_new_emails.assert_called_once()
        mock_name.return_value.process_email.assert_called_once()
        mock_discord.return_value.send_email_notification.assert_called_once()
        mock_discord.return_value.send_response_options.assert_called_once()

def run_async_test(test_func):
    """非同期テスト関数を実行するヘルパー"""
    loop = asyncio.get_event_loop()
    loop.run_until_complete(test_func())

if __name__ == '__main__':
    # 非同期テストを実行
    run_async_test(TestIntegration().test_email_processing_flow)
    print("統合テスト成功")
```

### 9.3 テスト方法

統合テストの実行：

```bash
python -m gmail_discord_bot.tests.test_integration
```

全テストの実行：

```bash
python -m unittest discover -s gmail_discord_bot/tests
```

---

## 10. デプロイメント

### 10.1 必要なファイルの準備

1. `requirements.txt`を作成：

```
google-api-python-client>=2.0.0
google-auth-httplib2>=0.1.0
google-auth-oauthlib>=0.4.0
discord.py>=2.0.0
openai>=0.27.0
python-dotenv>=0.19.0
sqlalchemy>=1.4.0
pytz>=2021.1
pytest>=6.0.0
```

2. `README.md`を作成：

```markdown
# Gmail-Discord自動転送・返信システム

GmailからDiscordへのメール自動転送と、ChatGPT APIを活用した返信候補生成システム。

## 機能

- Gmailで受信したメールをDiscordチャンネルへ自動転送
- 送信元情報から適切な宛名（〇〇会社 〇〇様）を自動設定
- ChatGPT APIを使用した複数の返信パターン生成
- 日程調整メールの場合はGoogleカレンダーと連携した候補日時の提案

## セットアップ

1. 必要なパッケージのインストール
   ```
   pip install -r requirements.txt
   ```

2. 各APIの認証情報を設定
   - Gmail API
   - Discord API
   - OpenAI API
   - Googleカレンダー API

3. 設定ファイルの作成
   - `.env`ファイルを`config/.env.example`を参考に作成
   - メールアドレスとDiscordチャンネルのマッピングを設定

4. 実行
   ```
   python -m gmail_discord_bot.main
   ```

## 使用方法

1. Discordボットを招待したサーバーでコマンドを使用
   - `!help` - ヘルプを表示
   - `!select [番号]` - 返信候補を選択
   - `!send [番号]` - 選択した返信を送信

## ライセンス

MIT
```

### 10.2 デプロイ手順

#### 10.2.1 ローカル環境でのデプロイ

```bash
# 仮想環境の作成と有効化
python -m venv venv
source venv/bin/activate  # Windowsの場合: venv\Scripts\activate

# 必要なパッケージのインストール
pip install -r requirements.txt

# 設定ファイルの準備
cp gmail_discord_bot/config/.env.example gmail_discord_bot/config/.env
# .envファイルを編集して必要な認証情報を設定

# 実行
python -m gmail_discord_bot.main
```

#### 10.2.2 サーバー環境でのデプロイ

```bash
# サーバーにSSH接続
ssh user@your-server

# リポジトリをクローン
git clone https://github.com/yourusername/gmail-discord-bot.git
cd gmail-discord-bot

# 仮想環境の作成と有効化
python -m venv venv
source venv/bin/activate

# 必要なパッケージのインストール
pip install -r requirements.txt

# 設定ファイルの準備
cp gmail_discord_bot/config/.env.example gmail_discord_bot/config/.env
# .envファイルを編集して必要な認証情報を設定

# バックグラウンドで実行
nohup python -m gmail_discord_bot.main > bot.log 2>&1 &
```

#### 10.2.3 Dockerを使用したデプロイ

`Dockerfile`を作成：

```dockerfile
FROM python:3.9-slim

WORKDIR /app

COPY requirements.txt .
RUN pip install --no-cache-dir -r requirements.txt

COPY . .

CMD ["python", "-m", "gmail_discord_bot.main"]
```

`docker-compose.yml`を作成：

```yaml
version: '3'

services:
  bot:
    build: .
    volumes:
      - ./gmail_discord_bot/config:/app/gmail_discord_bot/config
    restart: unless-stopped
```

デプロイ手順：

```bash
# Dockerイメージをビルド
docker-compose build

# コンテナを起動
docker-compose up -d

# ログの確認
docker-compose logs -f
```

### 10.3 テスト方法

デプロイ後のテスト：

1. システムが正常に起動しているか確認
   ```bash
   # プロセスの確認
   ps aux | grep python
   
   # ログの確認
   tail -f bot.log
   ```

2. Discordボットが正常に動作しているか確認
   - Discordサーバーでボットがオンラインになっているか確認
   - `!help`コマンドを実行して応答があるか確認

3. メール受信テスト
   - テスト用のメールを送信
   - Discordの対応するチャンネルにメールが転送されるか確認
   - 返信候補が生成されるか確認

---

## 11. 運用とメンテナンス

### 11.1 ログ監視

ログを定期的に確認し、エラーや問題がないか監視します：

```bash
# ログの確認
tail -f bot.log

# エラーログの抽出
grep ERROR bot.log
```

### 11.2 定期的なバックアップ

データベースや設定ファイルを定期的にバックアップします：

```bash
# 設定ファイルとデータベースのバックアップ
mkdir -p backups/$(date +%Y%m%d)
cp -r gmail_discord_bot/config/*.json backups/$(date +%Y%m%d)/
```

### 11.3 アップデート手順

新しいバージョンへのアップデート手順：

```bash
# リポジトリの更新
git pull

# 依存関係の更新
pip install -r requirements.txt --upgrade

# 再起動
# プロセスを停止
pkill -f "python -m gmail_discord_bot.main"
# 再起動
nohup python -m gmail_discord_bot.main > bot.log 2>&1 &
```

### 11.4 トラブルシューティング

よくある問題と解決策：

1. API認証エラー
   - 認証情報が正しいか確認
   - トークンの有効期限が切れていないか確認
   - 必要な権限が付与されているか確認

2. メールが転送されない
   - Gmail APIの接続状態を確認
   - メールとDiscordチャンネルのマッピングが正しいか確認
   - ログでエラーメッセージを確認

3. 返信候補が生成されない
   - OpenAI APIの接続状態を確認
   - APIキーの有効期限と使用制限を確認
   - プロンプトが適切か確認

4. Discordボットが応答しない
   - ボットのトークンが正しいか確認
   - ボットに必要な権限が付与されているか確認
   - Discordの接続状態を確認

### 11.5 パフォーマンス最適化

システムのパフォーマンスを最適化するためのヒント：

1. メールチェック間隔の調整
   - トラフィックが少ない場合は間隔を長くする
   - 重要なメールが多い場合は間隔を短くする

2. ChatGPT APIの使用量最適化
   - 不要な生成を減らす
   - トークン数を適切に設定する

3. データベースの最適化
   - 定期的にクリーンアップを行う
   - インデックスを適切に設定する

4. メモリ使用量の監視
   - 長時間稼働時のメモリリークに注意
   - 必要に応じて定期的に再起動するスクリプトを設定